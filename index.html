<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">

        <title>Welcome to Nabla's 3D Page</title>



    <link rel="stylesheet" type="text/css" href="styles.css?v=1.0.32">




        <script src="my3dengine.js"></script>

</head>
<body>








<nav>


    <a href="index.html"><img src="logos/nabla.png" alt="logo" /></a>

    <a href="index.html">Home</a>
    <a href="research.html">Research</a>
    <a href="contact.html">Contact</a>
    <a href="MyCube.html">My 3D Cube</a>
</nav>







	

<section>

    <div class="container">
    <div class="text">

    <h2>About Me</h2>
    </div>
    </div>





    <div class="container0">
        

    <div class="image">
        <img src="aboutme/me.jpg" alt="My Photo">
    </div>

    <div class="text">
                <p>我目前在浙江大学，从事CG及其与Internet的交叉研究。曾设计N-Alien机器人，对机器人上位软件架构、集成电路、运动控制算法、力学结构设计均有落地级别的研究。
        科研期间接触数学梯度算符Nabla，觉得很美，故以此为英文名。
        </p>
	    <br>
                    <p><b>转动导航魔方，查看科研详情：</b>
        </p>
    </div>


    </div>

             <canvas id="renderCanvas" ></canvas>




















    <div class="container">
    <div class="text">


     <h2>My Research</h2>


    </div>
    </div>


    <canvas id="renderCanvas02" ></canvas>











<div class="container-wrapper">


    <div class="container1">

        <div class="image1">
        <img id="GISys" src="GISys/GISys.png"  alt="Nabla's GISys">

    </div>

    <div class="text1">
                <p> <b> WebGI-全局照明渲染系统：</b>web因其可扩展性和跨平台特性，在渲染行业具有巨大潜力，我们提出了新方法在web上渲染出带有全局照明效果的3D场景，同时把它部署到web系统上。
        </p>


    </div>
    </div>

















        <div class="container1">

        <div class="image1">
        <img id="uvuw" src="UVUnwrapping/uvuw.png"  alt="Nabla's uvuwSys">

    </div>

    <div class="text1">
                <p> <b> Web UV参数化系统：</b>uv参数化是判断3D模型完整度的标志，在三维重建和渲染中起关键作用，我们考虑web特性，设计了WUVP系统及支持它运行的大型稀疏方程求解器。
        </p>


    </div>



    </div>


    </div>








<div class="container-wrapper">



    <div class="container1">





        <div class="image1">
        <img id="NAlien" src="NAlien/NAlien.jpg"  alt="Nabla's Alien">

    </div>
    <div class="text1">
                <p> <b> N-Alien机器人：</b>我从AI视觉系统、上位软件架构、运动控制算法、集成电路系统、机器人3D架构入手，创造了它，它具有远程GPS定位、AI视觉探测以及良好的运动能力。
        </p>


    </div>

    </div>




    </div>



    <div class="container">
    <div class="text">
        
     <h2>My Awards</h2>


    </div>
    </div>

        <div class="container">

    <div class="text">



        <h3>1 National Scholarship </h3>
           <p>Certification ID：BZK202054374 </p>

        <h3>2 Invention Patent </h3>
           <p>Publication number：CN116630574A, "一种流形曲面模型有序边缘链快速求解方法",赵晓阳.etc </p>

        <h3>3 Utility Model Patent </h3>
           <p>Publication number：CN218317008U, "一种模块化四足机器人腿部结构",赵晓阳.etc</p>



    </div>


    </div>






</section>

<footer>
    <p>&copy; 2024 Nabla's Website. All rights reserved.</p>
</footer>














	<script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const canvas02 = document.getElementById("renderCanvas02"); // Get the canvas element

//canvas02
		

canvas02.addEventListener("wheel", function(event) {
event.preventDefault();
});
	
		
  var width02 = canvas02.offsetWidth;
  var height02 = width02 * 0.70; // 高度为宽度的两倍
  canvas02.width = width02;
  canvas02.height = height02;	


        const engine02 = new BABYLON.Engine(canvas02, true); // Generate the BABYLON 3D engine



        const createScene02 = function () {
            // This creates a basic Babylon Scene object (non-mesh)
            const scene02 = new BABYLON.Scene(engine02);
            scene02.clearColor=new BABYLON.Color4(0,0,0,0);

        // This creates and positions a free camera (non-mesh)
        var camera02 = new BABYLON.ArcRotateCamera("camera", 0, Math.PI/2, 25, BABYLON.Vector3.Zero(), scene02);
        // This targets the camera to scene origin
        camera02.setTarget(BABYLON.Vector3.Zero());

        // This attaches the camera to the canvas
        camera02.attachControl(canvas02, true);

        // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
        var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene02);

        // Default intensity is 1. Let's dim the light a small amount
        light.intensity = 0.7;



        var ground1 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);
        var ground2 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);
        var ground3 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);
        var ground4 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);
        var ground5 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);
        var ground6 = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 4}, scene02);


var mat=new BABYLON.StandardMaterial('',scene02);
mat.backFaceCulling=false;


scene02.registerBeforeRender(automove);

var time=0;

function automove () {
time+=scene02.getEngine().getDeltaTime()/10000;
var strength = Math.abs( Math.sin(time*2)*1.2); 
mat.emissiveColor=new BABYLON.Color3(0.16*strength, 0.78*strength, 0.73*strength);
camera02.alpha+=time/10000;

}





var radius=10;
var jump=2*Math.PI/scene02.meshes.length;



for(let i=0;i<6;i++){


   var pos=new BABYLON.Vector3(Math.sin(i*jump)*radius,0,Math.cos(i*jump)*radius);

    scene02.meshes[i].position=pos;
    scene02.meshes[i].rotation.x=-Math.PI/2
    scene02.meshes[i].rotation.y=i*jump

    scene02.meshes[i].material=mat;



}


		



		
        return scene02;
        };





        const scene02 = createScene02(); //Call the createScene function
        // Register a render loop to repeatedly render the scene
        engine02.runRenderLoop(function () {
                scene02.render();
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine02.resize();
        });


		
//canvas02





		


       // canvas.addEventListener('wheel', function(e) {e.preventDefault();});


		

  var width = canvas.offsetWidth;
  var height = width * 0.70; // 高度为宽度的两倍
  canvas.width = width;
  canvas.height = height;		
 
        //canvas.style.outline = 'none';
/*
       

 
 
 var windowWidth = window.innerWidth;

        canvas.width = windowWidth;
        canvas.height = 600;

        window.addEventListener('resize', function() {
            var newWindowWidth = window.innerWidth;
            canvas.width = newWindowWidth;
        });

*/





        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine



        const createScene = function () {
            // This creates a basic Babylon Scene object (non-mesh)
            const scene = new BABYLON.Scene(engine);
            scene.clearColor=new BABYLON.Color4(0,0,0,0);









    var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 10, BABYLON.Vector3(0,0,0), scene);
    camera.attachControl(canvas, true);
    camera.position=new BABYLON.Vector3(5.0,-1.2,5.0);
    camera.wheelPrecision=100;
    camera.lowerRadiusLimit = 4.2; // 设置最小距离







var isPointerOverMesh = false;

// 监听鼠标移动事件
canvas.addEventListener("mousemove", function(event) {
    // 获取鼠标位置
    var pickInfo = scene.pick(scene.pointerX, scene.pointerY);
    
    if (pickInfo.hit && pickInfo.pickedMesh) {
        // 如果鼠标碰到了模型，则启用相机控制
        scene.activeCamera.attachControl(canvas, true);
        isPointerOverMesh = true;
    } else {
        // 如果鼠标不在模型上，则禁用相机控制
        scene.activeCamera.detachControl(canvas);
        isPointerOverMesh = false;
    }
});


		
// 监听滚轮事件
canvas.addEventListener("wheel", function(event) {
    if (!isPointerOverMesh) {
        // 如果鼠标不在模型上，则滚动页面
        window.scrollBy(0, event.deltaY);
    } else{event.preventDefault();}

});






















// 获取 container-wrapper 元素
var containerWrapper = document.querySelector(".container-wrapper");

// 获取 container1 元素
var container1 = document.querySelector(".container1");

// 获取 image1 元素
var image1 = document.querySelector(".image1");

// 监听鼠标移动事件
canvas.addEventListener("mousemove", function(event) {
    // 获取鼠标位置
    var pickInfo = scene.pick(scene.pointerX, scene.pointerY);
    
    if (!pickInfo.hit || !pickInfo.pickedMesh) {
        // 如果鼠标不在模型上，则将事件传递到 containerWrapper、container1 和 image1
        containerWrapper.dispatchEvent(new MouseEvent('mousemove', event));
        container1.dispatchEvent(new MouseEvent('mousemove', event));
        image1.dispatchEvent(new MouseEvent('mousemove', event));
    }
});

// 监听鼠标点击事件
canvas.addEventListener("mousedown", function(event) {
    // 获取鼠标位置
    var pickInfo = scene.pick(scene.pointerX, scene.pointerY);
    
    if (!pickInfo.hit || !pickInfo.pickedMesh) {
        // 如果鼠标不在模型上，则将事件传递到 containerWrapper、container1 和 image1
        containerWrapper.dispatchEvent(new MouseEvent('mousedown', event));
        container1.dispatchEvent(new MouseEvent('mousedown', event));
        image1.dispatchEvent(new MouseEvent('mousedown', event));
    }
});






















                   









var pointlight1=new BABYLON.PointLight('p1',new BABYLON.Vector3(0,0,2),scene)

var hemilight = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, -1, 0), scene);



var texture1 = new BABYLON.Texture("NAlien/NAlien.jpg", scene);
var texture2 = new BABYLON.Texture("GISys/GISys.png", scene);
var texture3 = new BABYLON.Texture("UVUnwrapping/uvuw.png", scene);

var materialimgs=[texture1,texture2,texture3];

/*
var texture2 = new BABYLON.Texture("GISys/GISys.png", scene);
var texture3 = new BABYLON.Texture("GISys/GISys.png", scene);
var texture4 = new BABYLON.Texture("GISys/GISys.png", scene);
var texture5 = new BABYLON.Texture("GISys/GISys.png", scene);
var texture6 = new BABYLON.Texture("GISys/GISys.png", scene);

var materialimgs=[texture1,texture2,texture3,texture4,texture5,texure6];

*/



    // URL array
    var urls = [
        "NAlien.html",
        "GISys.html",
        "uvuw.html",
        "https://www.facebook.com/",
        "https://www.twitter.com/",
        "https://www.instagram.com/"
    ];

    // Function to create plane with material and action
    function createPlaneWithAction(name, position, rotation,url,materialimg) {
        var plane = BABYLON.MeshBuilder.CreatePlane(name, { size: 2 }, scene);
        plane.position = position;
        plane.rotation = rotation; // Rotate to face the camera

        // Apply material with texture as URL
        var material = new BABYLON.StandardMaterial("material" + name, scene);
        //material.diffuseColor=new BABYLON.Color3(0.07, 0.62, 0.76, 0.62)
        material.diffuseTexture=materialimg;
        material.backFaceCulling=false;
        plane.material = material;


        // Add action to open URL on click
        plane.actionManager = new BABYLON.ActionManager(scene);
        plane.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function (evt) {
                        window.location.href = url;

                }
            )
        );

        return plane;
    }


    var positions = [
        new BABYLON.Vector3(-1, 0,0), // Front
        new BABYLON.Vector3(1, 0, 0), // Front
        new BABYLON.Vector3(0, 0, 1), // Front
        new BABYLON.Vector3(0, 0, -1), // Front
        new BABYLON.Vector3(0, 1, 0), // Front
        new BABYLON.Vector3(0, -1, 0) // Bottom
    ];

    var rotations = [
        new BABYLON.Vector3(0, Math.PI/2, 0), // Front
        new BABYLON.Vector3(0, Math.PI/2, 0), // Front
        new BABYLON.Vector3(0, 0, 0), // Front
        new BABYLON.Vector3(0, 0, 0), // Front
        new BABYLON.Vector3( Math.PI/2, 0, 0), // Front
        new BABYLON.Vector3( Math.PI/2, 0, 0) // Bottom
    ];

    // Create planes and assign URLs for the box
    var boxPlanes = [];


    for (var i = 0; i < 6; i++) {
        var plane = createPlaneWithAction("plane" + i, positions[i], rotations[i], urls[i],materialimgs[i]);
        boxPlanes.push(plane);
    }















var time=0;








scene.registerBeforeRender(automove);

canvas.addEventListener("pointerdown", onMouseDown);
canvas.addEventListener("pointerup", onMouseUp);






















function automove () {







time+=scene.getEngine().getDeltaTime()/10000;



    var radius=0.1;
    var speed=12;


    var x = Math.sin(time*speed ) * radius;
    var y= Math.cos(time*speed ) * radius;
    var z = Math.cos(time*speed) * radius;


hemilight.intensity=Math.abs( Math.sin(time ))*3 ;
hemilight.direction=new BABYLON.Vector3(x,1,z);
pointlight1.intensity=Math.abs( Math.cos(time*3 ))*1 ;


for (let i = 0; i < boxPlanes.length; i++) {
    boxPlanes[i].position = new BABYLON.Vector3(x+positions[i].x, y+positions[i].y, z+positions[i].z);
}

}


function onMouseDown(event) {
scene.unregisterBeforeRender(automove);


}

function onMouseUp(event) {
scene.registerBeforeRender(automove);

}




















            
            
            
            
            
            return scene;
        };





        const scene = createScene(); //Call the createScene function
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
	</script>


























</body>
</html>
